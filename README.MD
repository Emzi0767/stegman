# PRM Project - 18L Semester
This is my project for the conclusion of PRM labs in the 18L semester on the 
Electronics faculty of Warsaw Institute of Technology.

# Description
This project is a tool that employs cryptography and steganography to safely 
hide messages in various files. It can also reverse the process to extract 
information from a file.

## Encoding
The user has to specify the file in which data will be encoded, a password, 
and the message to hide. The hiding procedure works as follows:

1.  User selects a PNG image in which the message will be hidden
2.  User inputs the message to hide (can be a file)
3.  User inputs the password used to secure the message
4.  Program creates an IV for encryption, by creating a 16-byte array and 
    filling it with data generated by a CSPRNG.
5.  Program creates a salt for hashing, in the same manner as the IV.
6.  Program generates a random number between 32767 and 65535, which determines
    the number of cycles the password will be hashed.
7.  The program salts the password, hashes it with SHA-256, and repeats the 
    cycle n times (n is the number generated in step 6).
8.  The resulting 256-bit value is then used as key for AES-256 encryption.
9.  The program compresses the plain message using ZLib.
10. The program encrypts a value of `0x0BADFACE` as a control value, then the 
    compressed message.
11. The program encodes a value of `0x0BADFACE` into the target image, followed
    by flags specifying properties of the message, followed by hash cycle 
    count, followed by IV, followed by salt, followed by length of encrypted 
    message, then the encrypted message.

The encoding occurs on 2 least significant bits of each color component of 
each pixel in the target PNG image. So assuming ARGB32-encoded image, it takes 
1 pixel to encode 1 byte (4 x 2 bits = 8 bits = 1 byte). Thus for ARGB32 
images, the final (compressed + encrypted) message can be 
`width * height - 4 - 4 - 2 - 16 - 16 - 8` bytes long. This is because:

* `0x0BADFACE` is a 32-bit integer (4 bytes), used as magic value to determine 
  whether any data is present at all.
* The flags are encoded as a 32-bit integer (4 bytes). The documentation for 
  them is available below.
* Hash cycle count is a 16-bit unsigned integer (2 bytes).
* IV is 16 bytes.
* Salt is 16 bytes.
* Length is encoded as a 64-bit integer (8 bytes), it does not include padding.

The length encoded is without padding. AES-256 encrypts data in 256-bit 
(32-byte) blocks. This means the encrypted message length will be rounded up to
nearby 32. Knowing that, we can encode the length without padding, because we 
can easily calculate the length of the padded message.

## Decoding

The user has to specify the PNG file containing a hidden message, and password 
to decrypt it. The program then attempts to find, identify, and extract the 
message. If the input message was a file, the user has to specify the output 
file name. The procedure works as follows:

1.  Program decodes first 4 bytes, and checks if they equal `0x0BADFACE`. If 
    they don't, the user is notified that the file does not contain a message 
    and the program exits.
2.  Program decodes the message properties, hash cycle count, IV, salt, and 
    data length.
3.  Program calculates the encrypted length by rounding up length to nearest 
    32.
4.  Program decodes first 32 bytes of the encrypted message.
5.  Program calculates the encryption key by salting the key, hashing it with 
    SHA-256, and repeating the procedure n times, where n is the hash cycle 
    count.
6.  Program attempts to decrypt the 32 bytes using the AES-256 algorithm, with 
    the IV and key it computed.
7.  If the first 4 bytes of the decoded message are not equal to `0x0BADFACE`, 
    the user is notified that the password they supplied is invalid, and the 
    program exits.
8.  The program decodes and decrypts the rest of the message.
9.  The program decompresses the decrypted message using ZLib.
10. The program displays the message, or, if the message was a file, writes it 
    to specified path.

## Message Properties
The 32-bit properties bitfield contains information about the source message. 
Descriptions of specific bits can be found below:

**Bit** | **Value**    | **Description**
:-------|:-------------|:----------------
0       | `0x00000001` | The input message was a file

# Requirements
The program was designed to work under GNU/Linux environments. It might work 
under other POSIX-compatible systems, provided appropriate prerequisites are 
installed, however that is not guaranteed. Furthermore the program was not 
tested under Windows at all.

Under Debian 10 (Buster) all requirements can be installed by doing:

```bash
$ sudo apt-get install clang-6.0 lld-6.0 llvm-6.0 libssl-dev zlib1g-dev libpng-dev make build-essential git
```

Then you can simply clone this repository, and in its root directory, run 
`make CC=clang-6.0 LD=lld`

## Libraries
* OpenSSL
* ZLib
* libpng

## Operating System
Any modern GNU/Linux distribution. The program was written for Debian 10 
(Buster), and tester under Debian 9 (Stretch).

Any POSIX-compatible UNIX (such as FreeBSD) might also work.

## Compiler, Linker, Make
The program was tested to compile with Clang 6.0, and linked with LLD 6.0. 
However, any C99-capable compiler should do the job.

To build the program, you need a Make implementation available on your system. 
The program was tested with GNU Make.

# License
The program and the source are shared under MIT License. See LICENSE file for 
details.
